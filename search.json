[{"title":"关于树","url":"http://fxsong.xyz/2021/03/05/关于树/","content":"定义在数据结构中，树的定义如下。树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。\n\n有且仅有一个特定的称为根的节点。\n当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。\n\n树的最大层级数，被称为树的高度或深度。\n二叉树二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点 。注意，这里是最多有2个，也可能只有1个，或者没有孩子节点。\n满二叉树： 一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。完全二叉树： 对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同，则这个二叉树为完全二叉树。\n物理存储结构\n1.链式存储结构每一个节点：\n\n存储数据的 data 变量\n指向左孩子的 left 指针\n指向右孩子的 right指针\n\n2.数组\n\n按层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的对应位置也空出来。\n假设一个父节点的下标是parent，那么它的左孩子节点下标就是2×parent + 1 ；右孩子节点下标就是2×parent + 2。\n\n二叉查找树限定条件：\n\n如果左子树不为空，则左子树上所有节点的值均小于根节点的值\n如果右子树不为空，则右子树上所有节点的值均大于根节点的值\n左、右子树也都是二叉查找树\n\n对一个节点分布相对均衡的二叉查找树来说，如果节点总数为n，那么搜索节点的时间复杂度就是 O(logn) ，和树的深度是一样的。\n遍历从节点之间位置关系的角度来看，二叉树的遍历分为4种。\n\n前序遍历（根、左、右）\n中序遍历（左、根、右）\n后序遍历（左、右、根）\n层序遍历（一层一层遍历）\n\n从更宏观的角度来看，二叉树的遍历归结为两大类。\n\n深度优先遍历（前序遍历、中序遍历、后序遍历）（递归、栈）。\n广度优先遍历（层序遍历）（队列）\n\n二叉堆二叉堆本质上是一种完全二叉树，它分为两个类型：\n\n最大堆最大堆的任何一个父节点的值，都大于或等于它左、右孩子节点的值。\n最小堆最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。\n\n二叉堆的根节点叫做堆顶。\n对于二叉堆，有如下几种操作。\n\n插入节点。（节点上浮）\n删除节点。（删除节点后判断然后下浮）\n构建二叉堆。\n\n这几种操作都基于堆的自我调整。\n二叉堆使用数组存储。假设父节点的下标是parent，那么它的左孩子下标就是 2×parent+1 ；右孩子下标就是2×parent+2。\n作用：用于实现优先队列和堆排序。\n优先队列最大（小）优先队列，无论入队顺序如何，都是当前最大（小）的元素优先出队。\n","categories":[],"tags":[]},{"title":"常用排序算法","url":"http://fxsong.xyz/2021/03/04/常用排序算法/","content":"冒泡排序冒泡排序相对来说思路简单，思想如下（升序）：遍历数组，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧元素时，位置不变。这样第一轮排序的最后最大的元素就到了队尾，接下来进行第二轮排序，直到数组有序。冒泡排序是一种稳定排序，平均时间复杂度是 **O(n²)**。\n\n    冒泡排序代码\n\n代码\npublic static int[] Bubble(int[] s)&#123;    int len = s.Length;    for (int i = len; i &gt; 0; --i)    &#123;        for (int j = 0; j &lt; len-1; ++j)        &#123;            if (s[j] &gt; s[j + 1])            &#123;                int temp = s[j];                s[j] = s[j + 1];                s[j + 1] = temp;            &#125;        &#125;    &#125;    return s;&#125;\n\n&nbsp\n\n\n快速排序快速排序的思路是：每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。这种思路叫做分治法。平均时间复杂度为 O(nlogn)**，最坏情况下为O(n²)**。\n几种实现方法（升序）\n双边循环法设置基准元素pivot，设置left和right左右指针，每一次循环分别找到左边比基准元素大，右边比基准元素小的两个index，然后交换这两个元素，直到 left==right。\n代码\n\n    双边循环代码\n\npublic static void QuickSort(int[] s,int startIndex,int endIndex)&#123;    //递归结束条件    if (startIndex &gt;= endIndex)        return;    //得到基准元素位置    int pivotIndex = Partition(s, startIndex, endIndex);    //根据基准元素，分成两部分进行递归排序    QuickSort(s, startIndex, pivotIndex-1);    QuickSort(s, pivotIndex + 1, endIndex);&#125;static int Partition(int[] s,int startIndex,int endIndex)&#123;    //取第一个位置元素为基准元素    int pivot = s[startIndex];    int left = startIndex;    int right = endIndex;    while(left!=right)    &#123;        //控制right指针比较并左移        while (left &lt; right &amp;&amp; s[right] &gt; pivot)        &#123;            right--;        &#125;        //控制left指针比较并右移        while (left &lt; right &amp;&amp; s[left] &lt;= pivot)        &#123;            left++;        &#125;        //交换left和right指针所指向的元素        if(left&lt;right)        &#123;            int p = s[left];            s[left] = s[right];            s[right] = p;        &#125;    &#125;    //pivot和指针重合点交换    s[startIndex] = s[left];    s[left] = pivot;    return left;&#125;\n\n&nbsp\n\n\n单边循环设置基准元素pivot，设置一个mark指针，指向数列起始位置。\n接下来，从基准元素的下一个位置开始遍历数组。\n如果遍历到的元素大于基准元素，就继续往后遍历。\n如果遍历到的元素小于基准元素，则需要做两件事：第一，把mark指针右移1位，因为小于pivot的区域边界增大了1；第二，让最新遍历到的元素和mark指针所在位置的元素交换位置，因为最新遍历的元素归属于小于pivot的区域。\n代码（仅改变了Partition中的代码）\n\n    单边循环代码\n\nstatic int Partition(int[] s,int startIndex,int endIndex)&#123;    int pivot = s[startIndex];    int mark = startIndex;    for (int i = startIndex + 1; i &lt;= endIndex; i++)    &#123;        if(s[i]&lt;pivot)        &#123;            mark++;            if(mark!=i)            &#123;                int p = s[i];                s[i] = s[mark];                s[mark] = p;            &#125;        &#125;    &#125;    s[startIndex] = s[mark];    s[mark] = pivot;    return mark;&#125;\n\n&nbsp\n\n非递归实现绝大多数的递归逻辑，都可以用栈的方式来代替。\n堆排序堆排序建立在二叉堆的基础上，思路：\n\n把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。\n循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。\n\n代码\n\n    堆排序代码\n\nstatic void downAdjust(int[] array,int parentIndex,int length)&#123;    //temp 保存父节点值，用于最后赋值    int temp = array[parentIndex];    int childIndex = 2 * parentIndex + 1;    while(childIndex&lt;length)    &#123;        //如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子        if (childIndex + 1 &lt; length &amp;&amp; array[childIndex + 1] &gt; array[childIndex])            childIndex++;        //如果父节点大于任何一个孩子的值，则直接跳出        if (temp &gt;= array[childIndex])            break;        //无须真正交换，单项赋值即可        array[parentIndex] = array[childIndex];        parentIndex = childIndex;        childIndex = childIndex * 2 + 1;    &#125;    array[parentIndex] = temp;&#125;public static void HeapSort(int[] array)&#123;    int len = array.Length;    //将无序数组构建成最大堆    for (int i = (len - 2) / 2; i &gt;= 0; i--)    &#123;        downAdjust(array, i, len);  //从最后一个非叶子节点开始进行“下沉”操作    &#125;    for (int i = len - 1; i &gt; 0; i--)    &#123;        //最后一个元素和第一个元素进行交换        int temp = array[i];        array[i] = array[0];        array[0] = temp;        //“下沉”调整最大堆        downAdjust(array, 0, i);    &#125;&#125;\n\n\n计数排序适用于一定范围内的整数排序，思路：根据整数取值范围确定数组，遍历整数序列，将每一个整数按照其值对号入座，同时，对应数组下标的元素进行加1操作。最后直接输出这个数组，直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。\n数组大小的确定：len = 数列最大值-最小值+1 \n变形：从统计数组的第二个元素开始，每一个元素都加上前面所有元素之和（可以用于确定相同整数的排序，如成绩排名）\n\n    计数排序代码\n\npublic static int[] CountSort(int[] array)&#123;    //得到数列的最大值和最小值，并计算差值d    int max = array[0];    int min = array[0];    for(int i=0;i&lt;array.Length;i++)    &#123;        if (array[i] &gt; max)            max = array[i];        if (array[i] &lt; min)            min = array[i];    &#125;    int d = max - min;    //创建统计数组并统计对应元素个数    int[] countArray = new int[d + 1];    for(int i=0;i&lt;array.Length;i++)    &#123;        countArray[array[i] - min]++;    &#125;    //统计数组做变形，后面的元素等于前面的元素之和    for(int i=1;i&lt;countArray.Length;i++)    &#123;        countArray[i] += countArray[i - 1];    &#125;    //倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组    int[] sortedArray = new int[array.Length];    for(int i=array.Length-1;i&gt;=0;i--)    &#123;        sortedArray[countArray[array[i] - min] - 1] = array[i];        countArray[array[i] - min]--;    &#125;    return sortedArray;&#125;\n\n\n&nbsp\n\n桶排序线性时间的排序算法。每一个桶（bucket）代表一个区间范围，里面可以承载一个或多个元素。\n具体需要建立多少个桶，如何确定桶的区间范围，有很多种不同的方式。我们这里创建的桶数量等于原始数列的元素数量，除最后一个桶只包含数列最大值外，前面各个桶的区间按照比例来确定。思路：\n\n确定桶的区间范围\n\n区间跨度 = （最大值-最小值） / （桶的数量-1）2. 遍历原始数列，把元素对号入座放入各个桶中。3. 对每个桶内部的元素分别进行排序。4. 遍历所有的桶，输出所有元素。\n常用排序算法复杂度\n","categories":[],"tags":[]},{"title":"比特位计数","url":"http://fxsong.xyz/2021/03/03/比特位计数/","content":"题目描述给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。\n示例1\n\n输入： 5输出： [0,1,1,2,1,2]\n\n题解\n方法一：直接计算这应该是我们最先想到的方法，即计算每一个数的二进制1的个数。这种方法的时间复杂度为 *O(k × m)*，空间复杂度为 *O(1)*（返回结果不计入空间复杂度）。\n方法二：动态规划我们假设 0 ≤ j &lt; i,那么我们是否可以通过已知 j 的二进制1的个数去求 i 的，这也是动态规划的思想，那么我们要通过求 dp 的表达式去构思代码。我们知道 n&amp;(n-1) 会将 n 二进制最右边的1置0，所以可以通过这一点来构思 dp 方程。即 dp[x]=dp[x&amp;(x-1)]+1 。\nC#代码\npublic int[] CountBits(int num) &#123;    int[] dp=new int[num+1];    for(int i=1;i&lt;num+1;++i)    &#123;        dp[i]=dp[i&amp;(i-1)]+1;    &#125;    return dp;&#125;\n\n时间复杂度：O(n)空间复杂度：O(1) （返回结果不计入空间复杂度）\n题目来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/counting-bits\n位运算常用技巧获取最右边的1：x &amp; (-1)最右边1置0：x &amp; (x-1)判断奇偶：(a&amp;1) == 1\n","categories":[],"tags":[]}]