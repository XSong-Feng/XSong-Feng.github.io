[{"title":"","url":"http://fxsong.xyz/2021/02/26/leetcode算法学习/","content":"关于栈第一道（判断括号）题目描述有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。\n如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。\n给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。\n对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。\n\n思路result字符串保存结果遍历字符串左括号入栈：若入栈后栈的长度大于1，即该左括号不是原语首个左括号，结果加入’(‘右括号出栈：若出栈后栈的长度大于0，即该右括号不是原语末个右括号，结果加入’)’\n\n双指针（滑动窗口）第一道（连续子数组）题目描述给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为 好子数组 。\n（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）\n返回 A 中 好子数组 的数目。\n\n思路我们要求的是【恰好有K个不同整数的子数组个数】，换一种思路，我们可以把问题转换成要求解【最多存在K个不同整数的子数组个数】和【最多存在K-1个不同整数的子数组个数】。\n\n\n代码\n\npublic class Solution &#123;    public int SubarraysWithKDistinct(int[] A, int K) &#123;        return AtMostKDistinct(A,K)-AtMostKDistinct(A,K-1);    &#125;    int AtMostKDistinct(int[] A,int K)  //求【最多存在K个不同整数的子数组个数】    &#123;        int l=A.Length; //数组长度        int r=0;        //返回值        int[] B=new int[l+1];        int right=0,left=0;     //左右指针        int count=0;         while(right&lt;l)        &#123;            if(B[A[right]]==0)                count++;            B[A[right]]++;            right++;            while(count&gt;K)            &#123;                B[A[left]]--;                if(B[A[left]]==0)                    count--;                left++;            &#125;            r+=right-left;  //这个需要记住        &#125;        return r;    &#125;&#125;\n\n反转数字（滑动窗口、差分数组）题目描述在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。\n返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。\n\n概念首先，我们先要了解差分数组的概念。差分数组的 定义 ：对于已知有n个元素的数列d，建立记录它每项与前一项差值的差分数组f：显然，f[1]=d[1]-0=d[1];对于整数i∈[2,n]，我们让f[i]=d[i]-d[i-1]。也就是说，差分数组是用来表示第 i 项与前一项的差值的，那么第 i-2 项与第 i 项的差值我们可以用第 i-1 项和第 i-2 项的差值和第 i 项与第 i-1 项的差值求出来。所以我们可以看到差分数组在算法中的主要用途：快速处理区间加减。假如现在要对数列区间 [L,R] 上的每个数都加上 x，那么通过 a[i]=f[i] 的前缀和的性质可以知道：\n\n第一个受影响的差分数组中的元素为 f[L]，所以令 f[L]+=x，那么后面数列元素在计算过程中都会加上 x。\n最后一个受影响的差分数组中的元素为 f[R]，所以令 f[R+1]-=x，那么可以保证不会影响到 R 以后数列元素的计算。这样一来，就不必对区间内每一个数进行处理，只需处理两个差分后的数即可。这也就是上一段所要表达的内容。\n\n\n思路差分数组如果采用通常的思路，本题的时间复杂度是 N^2^ 级别的，数组长度过大则会导致超时，所以我们要思考可不可以把时间复杂度降低到 O(N)。根据贪心算法的思想，我们需要翻转从左到右所有第一项为 0 的 K 长度子数组。考虑不去翻转数字，而是统计每个数字需要翻转的次数。对于一次翻转操作，相当于把子数组中所有数字的翻转次数加 1。\n这启发我们用差分数组的思想来计算当前数字需要翻转的次数。我们可以维护一个差分数组 diff，其中 diff[i] 表示两个相邻元素 A[i−1] 和 A[i] 的翻转次数的差，对于区间 [l,r]，将其元素全部加 1，只会影响到 l 和 r+1 处的差分值，故 diff[l] 增加 1，diff[r+1] 减少 1。\n通过累加差分数组可以得到当前位置需要翻转的次数，我们用变量 revCnt 来表示这一累加值。\n遍历到 A[i] 时，若 A[i]+revCnt 是偶数，则说明当前元素的实际值为 0，需要翻转区间 [i,i+K-1]，我们可以直接将 revCnt 增加 1，diff[i+K] 减少 1。\n注意到若 i+K&gt;n 则无法执行翻转操作，此时应返回 −1。\n代码\npublic int MinKBitFlips(int[] A, int K) &#123;    int n=A.Length;             //数组长度    int[] diff=new int[n+1];    //差分数组，翻转次数    int ans=0,revcnt=0;             for(int i=0;i&lt;n;++i)    &#123;        revcnt+=diff[i];        if((A[i]+revcnt)%2==0)        &#123;            if(i+K&gt;n)                return -1;            ans++;            revcnt=revcnt^1;            diff[i+K]=diff[i+K]^1;        &#125;    &#125;    return ans;&#125;\n\n滑动窗口能否将空间复杂度优化至 O(1) 呢？\n回顾方法一的代码，当遍历到位置 i 时，若能知道位置 i−K 上发生了翻转操作，便可以直接修改 revCnt，从而去掉 diff 数组。\n注意到 0≤A[i]≤1，我们可以用 A[i] 范围之外的数来表达「是否翻转过」的含义。\n具体来说，若要翻转从位置 ii 开始的子数组，可以将 A[i] 加 2，这样当遍历到位置 i′  时，若有 A[i’-K]&gt;1，则说明在位置 i’-K 上发生了翻转操作。\n代码\npublic int minKBitFlips(int[] A, int K) &#123;    int n = A.length;    int ans = 0, revCnt = 0;    for (int i = 0; i &lt; n; ++i) &#123;        if (i &gt;= K &amp;&amp; A[i - K] &gt; 1) &#123;            revCnt = revCnt^1;            A[i - K] -= 2; // 复原数组元素，若允许修改数组 A，则可以省略        &#125;        if (A[i] == revCnt) &#123;            if (i + K &gt; n) &#123;                return -1;            &#125;            ++ans;            revCnt = revCnt^1;            A[i] += 2;        &#125;    &#125;    return ans;&#125;\n\n最大连续1的个数给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。\n返回仅包含 1 的最长（连续）子数组的长度。\n思路本次的解题思路参考非官方解答。官方题解：https://leetcode-cn.com/problems/max-consecutive-ones-iii/。\n本题是采用滑动窗口去解答，首先我们分析题目，找到相应的思路（初次做题，思路对了，但是解题有问题）。分析本次代码：我们设立左右指针去维护滑动窗口，这次我们不去通过比较去维护一个最大值，而是维护一个只可以扩张的窗口，当窗口后移，我们在某一位置会得到最大的窗口（right-left），这也就是我们要求的长度，而后窗口后移，不满足此窗口内0的数量小于等于K，那么此窗口大小不会变。假如本题要求的是最大子数组，则不可以使用本方法。\n代码\npublic int LongestOnes(int[] A, int K) &#123;    int cnt=0,left=0,right=0,len=A.Length;    while(right&lt;len)&#123;        if(A[right]==0)             ++cnt;        ++right;        if(cnt&gt;K) &#123;            if(A[left]==0)                 --cnt;            ++left;        &#125;    &#125;    return right-left;&#125;\n\n\n\n数组第一道题目描述给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。\n找到所有在 [1, n] 范围之间没有出现在数组中的数字。\n您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。\n\n思路理解并熟悉常用的数组操作技巧。因为题目给出数组元素值的范围，因此可以借用此处。我们可以通过使数组元素加 n 的方式，判断并找出没有出现过的元素，此时它的值肯定小于 n。这里用了两种方法，前一种是最开始的思路，后一种官方解法。\n\n\n代码\n\npublic class Solution &#123;    public IList&lt;int&gt; FindDisappearedNumbers(int[] nums) &#123;        // HashSet&lt;int&gt; hashSet=new HashSet&lt;int&gt;();        // IList&lt;int&gt; l=new List&lt;int&gt;();        // for(int i=0;i&lt;nums.Length;++i)        // &#123;        //     if(hashSet.Contains(nums[i]))        //         continue;        //     else        //         hashSet.Add(nums[i]);        // &#125;        // for(int i=1;i&lt;=nums.Length;++i)        // &#123;        //     if(hashSet.Contains(i))        //         continue;        //     else        //         l.Add(i);        // &#125;        // return l;        int n=nums.Length;        foreach(int x in nums)        &#123;            int y=(x-1)%n;            nums[y]+=n;        &#125;        IList&lt;int&gt; r=new List&lt;int&gt;();        for(int i=0;i&lt;n;++i)        &#123;            if(nums[i]&lt;=n)                r.Add(i+1);        &#125;        return r;    &#125;&#125;\n\n并查集概念：\n","categories":[],"tags":[]}]